# Part 1: Technical Architecture

## Architectural Diagrams

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        WEB[Web Dashboard]
        MOBILE[Mobile App]
        API_CLIENT[API Clients]
    end
  
    subgraph "API Gateway"
        NGINX[Nginx Load Balancer]
        RATE_LIMIT[Rate Limiting]
        AUTH[Authentication]
    end
  
    subgraph "Application Layer"
        NODE1[Node.js App 1]
        NODE2[Node.js App 2]
        NODE3[Node.js App N]
    end
  
    subgraph "Processing Layer"
        QUEUE[Redis Queue]
        WORKER1[Worker 1]
        WORKER2[Worker 2]
        WORKER3[Worker N]
    end
  
    subgraph "Caching Layer"
        REDIS_CACHE[Redis Cache]
        REDIS_SESSION[Redis Sessions]
        REDIS_GEO[Redis Geo Index]
    end
  
    subgraph "Database Layer"
        PG_PRIMARY[(PostgreSQL Primary)]
        PG_REPLICA1[(PostgreSQL Replica 1)]
        PG_REPLICA2[(PostgreSQL Replica 2)]
    end
  
    subgraph "External Services"
        GHL[GoHighLevel API]
        GOOGLE[Google Maps API]
        TWILIO[Twilio SMS]
        SENDGRID[SendGrid Email]
    end
  
    WEB --> NGINX
    MOBILE --> NGINX
    API_CLIENT --> NGINX
  
    NGINX --> RATE_LIMIT
    RATE_LIMIT --> AUTH
    AUTH --> NODE1
    AUTH --> NODE2
    AUTH --> NODE3
  
    NODE1 --> QUEUE
    NODE2 --> QUEUE
    NODE3 --> QUEUE
  
    QUEUE --> WORKER1
    QUEUE --> WORKER2
    QUEUE --> WORKER3
  
    NODE1 --> REDIS_CACHE
    NODE2 --> REDIS_CACHE
    NODE3 --> REDIS_CACHE
  
    NODE1 --> PG_PRIMARY
    NODE2 --> PG_REPLICA1
    NODE3 --> PG_REPLICA2
  
    WORKER1 --> GHL
    WORKER2 --> GOOGLE
    WORKER3 --> TWILIO
    WORKER3 --> SENDGRID
```

### GHL Structure Overview

```mermaid
graph LR
    subgraph "GHL Account Hierarchy"
        MA[Master Agency Account]
  
        subgraph "Sub-Accounts by Region"
            R1[Region 1 - East Coast]
            R2[Region 2 - West Coast]
            R3[Region 3 - Central]
            R4[Region 4 - South]
            R5[Region 5 - Northwest]
        end
  
        subgraph "Location Sub-Accounts"
            L1[NYC - Manhattan]
            L2[NYC - Brooklyn]
            L3[LA - Beverly Hills]
            L4[LA - Santa Monica]
        end
    end
  
    MA --> R1
    MA --> R2
    MA --> R3
    MA --> R4
    MA --> R5
  
    R1 --> L1
    R1 --> L2
    R3 --> L3
    R3 --> L4
```

## A. System Architecture Overview

### GHL Structure Design

**Master Account Hierarchy:**
- **Agency Master Account**: Central control and lead distribution hub
- **Regional Sub-Accounts**: Group locations by geographic regions (East Coast, West Coast, Central, South, Northwest)
- **Location Sub-Accounts**: Individual gym locations with customized automations and pipelines

**Rationale**: This three-tier structure allows for regional management while maintaining individual location autonomy. Regional sub-accounts can handle area-specific promotions while location sub-accounts manage day-to-day operations.

### Custom Developments Required

1. **External Routing Engine**: Node.js API with PostgreSQL database to handle intelligent lead routing beyond GHL's native capabilities
2. **Capacity Management System**: Real-time tracking of location capacity with Redis caching for sub-second response times
3. **Analytics Dashboard**: Custom dashboard aggregating performance data across all locations with role-based access
4. **Webhook Processing Service**: Centralized webhook handler for real-time lead processing and routing decisions

### Data Flow Architecture

```
Lead Sources (FB/Google/Web) 
    ↓ 
GHL Master Account (Initial Capture)
    ↓ (Webhook)
Custom Routing Engine (Intelligent Assignment)
    ↓ (API Call)
Assigned Location Sub-Account (Local Processing)
    ↓ (Automation)
Location Team (Follow-up & Conversion)
```

**Key Decision**: Use GHL for lead capture and follow-up automation, but route intelligence through custom backend. This leverages GHL's strengths while adding sophisticated routing logic it cannot handle natively.

## B. Code Sample: Intelligent Lead Routing Function

**Choice**: Custom JavaScript function for GHL custom code action that intelligently routes leads based on location, lead score, and capacity.

**GHL Custom Code Action Implementation:**

```javascript
/**
 * Intelligent Lead Routing for Multi-Location Fitness Franchise
 * This code runs within GHL Custom Code Action in the master account automation
 */

async function intelligentLeadRouting(contactId, contactData) {
    const API_BASE = 'https://your-routing-api.com/api/v1';
    const API_KEY = 'your_secure_api_key'; // Stored in GHL custom fields
    
    try {
        // Extract lead information
        const leadInfo = {
            contactId: contactId,
            zipCode: contactData.postalCode || contactData.address1?.match(/\d{5}/)?.[0],
            source: contactData.source || 'direct',
            campaign: contactData.tags?.find(tag => tag.startsWith('utm_campaign_'))?.split('_')[2],
            leadScore: calculateLeadScore(contactData),
            timestamp: new Date().toISOString()
        };
        
        // Call routing API
        const routingResponse = await fetch(`${API_BASE}/routing/assign`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${API_KEY}`,
                'X-GHL-Location': process.env.GHL_LOCATION_ID
            },
            body: JSON.stringify(leadInfo)
        });
        
        if (!routingResponse.ok) {
            throw new Error(`Routing API error: ${routingResponse.status}`);
        }
        
        const routing = await routingResponse.json();
        
        if (routing.success) {
            // Update contact with routing information
            await updateContactFields(contactId, {
                'assigned_location_id': routing.locationId,
                'assigned_location_name': routing.locationName,
                'routing_reason': routing.reason,
                'routing_distance': routing.distance,
                'routing_timestamp': new Date().toISOString()
            });
            
            // Transfer to assigned location's sub-account
            await transferContactToSubAccount(contactId, routing.ghlSubAccountId);
            
            // Add to location-specific pipeline and stage
            await addContactToPipeline(contactId, routing.pipelineId, routing.initialStageId);
            
            // Trigger location-specific welcome automation
            await triggerAutomation(contactId, routing.welcomeAutomationId);
            
            // Send notification to assigned team
            await sendTeamNotification(routing.locationId, contactData, routing.reason);
            
            return {
                success: true,
                locationId: routing.locationId,
                reason: routing.reason,
                distance: routing.distance
            };
            
        } else {
            // Handle routing failure - assign to overflow location
            await handleRoutingFailure(contactId, contactData, routing.error);
            return { success: false, error: routing.error };
        }
        
    } catch (error) {
        console.error('Lead routing failed:', error);
        
        // Fallback to default location
        await handleEmergencyFallback(contactId, contactData, error.message);
        
        // Log error for analysis
        await logRoutingError(contactId, contactData, error);
        
        return { success: false, error: error.message };
    }
}

function calculateLeadScore(contactData) {
    let score = 50; // Base score
    
    // Source scoring
    const sourceScores = {
        'facebook': 70,
        'google': 85,
        'website': 90,
        'referral': 95,
        'walk-in': 100
    };
    score += (sourceScores[contactData.source?.toLowerCase()] || 0) - 50;
    
    // Engagement indicators
    if (contactData.email && contactData.phone) score += 20;
    if (contactData.tags?.includes('high-intent')) score += 30;
    if (contactData.customFields?.fitness_experience === 'experienced') score += 15;
    
    // Geographic preference (closer to gym = higher score)
    if (contactData.postalCode) {
        const zipPrefix = contactData.postalCode.substring(0, 3);
        // Add logic for zip code proximity scoring
    }
    
    return Math.min(Math.max(score, 0), 100);
}

async function updateContactFields(contactId, fields) {
    const updateData = Object.entries(fields).map(([key, value]) => ({
        key: key,
        field_value: value
    }));
    
    return await $ghl.contacts.updateContact(contactId, {
        customFields: updateData
    });
}

async function transferContactToSubAccount(contactId, subAccountId) {
    // Note: This would require GHL's contact transfer API
    // Implementation depends on available GHL API endpoints
    return await $ghl.contacts.transfer({
        contactId: contactId,
        targetLocationId: subAccountId
    });
}

async function handleRoutingFailure(contactId, contactData, error) {
    // Assign to overflow location (largest capacity or headquarters)
    const overflowLocationId = process.env.OVERFLOW_LOCATION_ID;
    
    await updateContactFields(contactId, {
        'assigned_location_id': overflowLocationId,
        'routing_status': 'overflow',
        'routing_error': error,
        'requires_manual_review': 'true'
    });
    
    // Trigger manual review automation
    await triggerAutomation(contactId, process.env.MANUAL_REVIEW_AUTOMATION_ID);
}

async function handleEmergencyFallback(contactId, contactData, error) {
    const defaultLocationId = process.env.DEFAULT_LOCATION_ID;
    
    await updateContactFields(contactId, {
        'assigned_location_id': defaultLocationId,
        'routing_status': 'emergency_fallback',
        'routing_error': error,
        'requires_immediate_attention': 'true'
    });
    
    // Immediate admin notification
    await sendAdminAlert(contactId, contactData, error);
}

async function sendTeamNotification(locationId, contactData, routingReason) {
    // Send SMS to location team
    const message = `New lead assigned: ${contactData.firstName} ${contactData.lastName} 
                    Phone: ${contactData.phone} 
                    Reason: ${routingReason}
                    Respond within 15 minutes for best conversion rates.`;
    
    return await $ghl.messages.send({
        locationId: locationId,
        message: message,
        recipients: ['team'] // GHL team notification system
    });
}

async function logRoutingError(contactId, contactData, error) {
    // Log to external service for analysis
    await fetch(`${API_BASE}/logs/routing-error`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            contactId,
            contactData: {
                firstName: contactData.firstName,
                lastName: contactData.lastName,
                phone: contactData.phone,
                email: contactData.email,
                source: contactData.source
            },
            error: error.message,
            timestamp: new Date().toISOString()
        })
    });
}
```

**Implementation Notes:**
- This code runs in GHL's Custom Code Action within the master account automation
- It makes API calls to our external routing service for intelligent decisions
- Includes comprehensive error handling and fallback mechanisms
- Provides detailed logging for performance analysis and optimization

## C. Automation Workflow: Facebook Ad Lead Processing

### Complete Lead Processing Flow

**Trigger**: Facebook lead form submission via GHL Facebook integration

**Step-by-Step Workflow:**

1. **Lead Capture** (GHL Native)
   - Facebook webhook delivers lead to GHL master account
   - Contact created with source tagged as "facebook"
   - Lead enters master funnel pipeline

2. **Data Enrichment** (Custom Code Action)
   - Extract and validate zip code from lead data
   - Geocode address if zip code missing or invalid
   - Calculate initial lead score based on form responses

3. **Intelligent Routing** (Custom Code Action - Above Function)
   - Call external routing API with lead data
   - Find closest 3 locations within service radius
   - Check capacity at each location in priority order
   - Assign to optimal location or fallback to overflow

4. **Location Assignment** (GHL Native + Custom)
   - Transfer contact to assigned location sub-account
   - Add to location-specific pipeline
   - Update custom fields with routing information

5. **Team Notification** (GHL Native)
   - Send SMS to assigned location team
   - Create task for immediate follow-up
   - Log notification in activity timeline

6. **Welcome Sequence** (GHL Automation)
   - Trigger location-specific welcome automation
   - Send personalized welcome email with gym details
   - Schedule follow-up SMS for appointment booking

7. **Capacity Update** (Webhook to External API)
   - Update location capacity in external system
   - Trigger capacity alerts if threshold reached
   - Update routing rules if location becomes unavailable

### Edge Case Handling

**Invalid Zip Code:**
- Attempt address geocoding
- If geocoding fails, assign to regional default location
- Flag for manual review

**No Available Capacity:**
- Check secondary and tertiary locations
- If all locations full, add to overflow queue
- Notify franchise owner of capacity issues
- Set up waitlist automation

**API Failures:**
- Immediate fallback to default location
- Log error for investigation
- Continue with standard automation flow
- Admin alert for system issues

**Duplicate Leads:**
- Check for existing contact by phone/email
- If duplicate found, update existing record
- Maintain lead source attribution
- Avoid duplicate follow-up sequences

### Performance Monitoring

- **Routing Response Time**: Target <500ms for routing decision
- **Assignment Success Rate**: Track percentage of successful assignments
- **Capacity Utilization**: Monitor location capacity in real-time
- **Conversion Tracking**: Measure conversion rates by routing method

### Business Rules Configuration

- **Service Radius**: Configurable maximum distance for lead assignment
- **Capacity Thresholds**: Customizable capacity limits per location
- **Priority Scoring**: Weighted factors for location selection
- **Blackout Periods**: Handle location closures and maintenance

This automation workflow ensures every Facebook lead is intelligently routed to the optimal location while maintaining data integrity and providing comprehensive fallback mechanisms for edge cases.

---
